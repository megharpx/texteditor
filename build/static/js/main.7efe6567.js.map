{"version":3,"file":"static/js/main.7efe6567.js","mappings":"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","sources":["../node_modules/workbox-window/_version.js","../node_modules/workbox-window/messageSW.js","../node_modules/workbox-core/_version.js","../node_modules/workbox-core/_private/Deferred.js","../node_modules/workbox-window/utils/urlsMatch.js","../node_modules/workbox-window/utils/WorkboxEvent.js","../node_modules/workbox-window/Workbox.js","../node_modules/workbox-core/_private/dontWaitFor.js","../node_modules/workbox-window/utils/WorkboxEventTarget.js","../node_modules/@babel/runtime/helpers/esm/createClass.js","../node_modules/@babel/runtime/helpers/esm/typeof.js","../node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js","../node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js","../node_modules/@babel/runtime/helpers/esm/defineProperty.js","../node_modules/@babel/runtime/helpers/esm/objectSpread2.js","../node_modules/idb/build/wrap-idb-value.js","../node_modules/idb/build/index.js","js/database.js","js/header.js","js/editor.js","../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","index.js"],"sourcesContent":["\"use strict\";\n// @ts-ignore\ntry {\n    self['workbox:window:6.5.3'] && _();\n}\ncatch (e) { }\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport './_version.js';\n/**\n * Sends a data object to a service worker via `postMessage` and resolves with\n * a response (if any).\n *\n * A response can be set in a message handler in the service worker by\n * calling `event.ports[0].postMessage(...)`, which will resolve the promise\n * returned by `messageSW()`. If no response is set, the promise will not\n * resolve.\n *\n * @param {ServiceWorker} sw The service worker to send the message to.\n * @param {Object} data An object to send to the service worker.\n * @return {Promise<Object|undefined>}\n * @memberof workbox-window\n */\n// Better not change type of data.\n// eslint-disable-next-line @typescript-eslint/ban-types\nfunction messageSW(sw, data) {\n    return new Promise((resolve) => {\n        const messageChannel = new MessageChannel();\n        messageChannel.port1.onmessage = (event) => {\n            resolve(event.data);\n        };\n        sw.postMessage(data, [messageChannel.port2]);\n    });\n}\nexport { messageSW };\n","\"use strict\";\n// @ts-ignore\ntry {\n    self['workbox:core:6.5.3'] && _();\n}\ncatch (e) { }\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport '../_version.js';\n/**\n * The Deferred class composes Promises in a way that allows for them to be\n * resolved or rejected from outside the constructor. In most cases promises\n * should be used directly, but Deferreds can be necessary when the logic to\n * resolve a promise must be separate.\n *\n * @private\n */\nclass Deferred {\n    /**\n     * Creates a promise and exposes its resolve and reject functions as methods.\n     */\n    constructor() {\n        this.promise = new Promise((resolve, reject) => {\n            this.resolve = resolve;\n            this.reject = reject;\n        });\n    }\n}\nexport { Deferred };\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport '../_version.js';\n/**\n * Returns true if two URLs have the same `.href` property. The URLS can be\n * relative, and if they are the current location href is used to resolve URLs.\n *\n * @private\n * @param {string} url1\n * @param {string} url2\n * @return {boolean}\n */\nexport function urlsMatch(url1, url2) {\n    const { href } = location;\n    return new URL(url1, href).href === new URL(url2, href).href;\n}\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport '../_version.js';\n/**\n * A minimal `Event` subclass shim.\n * This doesn't *actually* subclass `Event` because not all browsers support\n * constructable `EventTarget`, and using a real `Event` will error.\n * @private\n */\nexport class WorkboxEvent {\n    constructor(type, props) {\n        this.type = type;\n        Object.assign(this, props);\n    }\n}\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { Deferred } from 'workbox-core/_private/Deferred.js';\nimport { dontWaitFor } from 'workbox-core/_private/dontWaitFor.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { messageSW } from './messageSW.js';\nimport { WorkboxEventTarget } from './utils/WorkboxEventTarget.js';\nimport { urlsMatch } from './utils/urlsMatch.js';\nimport { WorkboxEvent } from './utils/WorkboxEvent.js';\nimport './_version.js';\n// The time a SW must be in the waiting phase before we can conclude\n// `skipWaiting()` wasn't called. This 200 amount wasn't scientifically\n// chosen, but it seems to avoid false positives in my testing.\nconst WAITING_TIMEOUT_DURATION = 200;\n// The amount of time after a registration that we can reasonably conclude\n// that the registration didn't trigger an update.\nconst REGISTRATION_TIMEOUT_DURATION = 60000;\n// The de facto standard message that a service worker should be listening for\n// to trigger a call to skipWaiting().\nconst SKIP_WAITING_MESSAGE = { type: 'SKIP_WAITING' };\n/**\n * A class to aid in handling service worker registration, updates, and\n * reacting to service worker lifecycle events.\n *\n * @fires {@link workbox-window.Workbox#message}\n * @fires {@link workbox-window.Workbox#installed}\n * @fires {@link workbox-window.Workbox#waiting}\n * @fires {@link workbox-window.Workbox#controlling}\n * @fires {@link workbox-window.Workbox#activated}\n * @fires {@link workbox-window.Workbox#redundant}\n * @memberof workbox-window\n */\nclass Workbox extends WorkboxEventTarget {\n    /**\n     * Creates a new Workbox instance with a script URL and service worker\n     * options. The script URL and options are the same as those used when\n     * calling [navigator.serviceWorker.register(scriptURL, options)](https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer/register).\n     *\n     * @param {string|TrustedScriptURL} scriptURL The service worker script\n     *     associated with this instance. Using a\n     *     [`TrustedScriptURL`](https://web.dev/trusted-types/) is supported.\n     * @param {Object} [registerOptions] The service worker options associated\n     *     with this instance.\n     */\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    constructor(scriptURL, registerOptions = {}) {\n        super();\n        this._registerOptions = {};\n        this._updateFoundCount = 0;\n        // Deferreds we can resolve later.\n        this._swDeferred = new Deferred();\n        this._activeDeferred = new Deferred();\n        this._controllingDeferred = new Deferred();\n        this._registrationTime = 0;\n        this._ownSWs = new Set();\n        /**\n         * @private\n         */\n        this._onUpdateFound = () => {\n            // `this._registration` will never be `undefined` after an update is found.\n            const registration = this._registration;\n            const installingSW = registration.installing;\n            // If the script URL passed to `navigator.serviceWorker.register()` is\n            // different from the current controlling SW's script URL, we know any\n            // successful registration calls will trigger an `updatefound` event.\n            // But if the registered script URL is the same as the current controlling\n            // SW's script URL, we'll only get an `updatefound` event if the file\n            // changed since it was last registered. This can be a problem if the user\n            // opens up the same page in a different tab, and that page registers\n            // a SW that triggers an update. It's a problem because this page has no\n            // good way of knowing whether the `updatefound` event came from the SW\n            // script it registered or from a registration attempt made by a newer\n            // version of the page running in another tab.\n            // To minimize the possibility of a false positive, we use the logic here:\n            const updateLikelyTriggeredExternally = \n            // Since we enforce only calling `register()` once, and since we don't\n            // add the `updatefound` event listener until the `register()` call, if\n            // `_updateFoundCount` is > 0 then it means this method has already\n            // been called, thus this SW must be external\n            this._updateFoundCount > 0 ||\n                // If the script URL of the installing SW is different from this\n                // instance's script URL, we know it's definitely not from our\n                // registration.\n                !urlsMatch(installingSW.scriptURL, this._scriptURL.toString()) ||\n                // If all of the above are false, then we use a time-based heuristic:\n                // Any `updatefound` event that occurs long after our registration is\n                // assumed to be external.\n                performance.now() > this._registrationTime + REGISTRATION_TIMEOUT_DURATION\n                ? // If any of the above are not true, we assume the update was\n                    // triggered by this instance.\n                    true\n                : false;\n            if (updateLikelyTriggeredExternally) {\n                this._externalSW = installingSW;\n                registration.removeEventListener('updatefound', this._onUpdateFound);\n            }\n            else {\n                // If the update was not triggered externally we know the installing\n                // SW is the one we registered, so we set it.\n                this._sw = installingSW;\n                this._ownSWs.add(installingSW);\n                this._swDeferred.resolve(installingSW);\n                // The `installing` state isn't something we have a dedicated\n                // callback for, but we do log messages for it in development.\n                if (process.env.NODE_ENV !== 'production') {\n                    if (navigator.serviceWorker.controller) {\n                        logger.log('Updated service worker found. Installing now...');\n                    }\n                    else {\n                        logger.log('Service worker is installing...');\n                    }\n                }\n            }\n            // Increment the `updatefound` count, so future invocations of this\n            // method can be sure they were triggered externally.\n            ++this._updateFoundCount;\n            // Add a `statechange` listener regardless of whether this update was\n            // triggered externally, since we have callbacks for both.\n            installingSW.addEventListener('statechange', this._onStateChange);\n        };\n        /**\n         * @private\n         * @param {Event} originalEvent\n         */\n        this._onStateChange = (originalEvent) => {\n            // `this._registration` will never be `undefined` after an update is found.\n            const registration = this._registration;\n            const sw = originalEvent.target;\n            const { state } = sw;\n            const isExternal = sw === this._externalSW;\n            const eventProps = {\n                sw,\n                isExternal,\n                originalEvent,\n            };\n            if (!isExternal && this._isUpdate) {\n                eventProps.isUpdate = true;\n            }\n            this.dispatchEvent(new WorkboxEvent(state, eventProps));\n            if (state === 'installed') {\n                // This timeout is used to ignore cases where the service worker calls\n                // `skipWaiting()` in the install event, thus moving it directly in the\n                // activating state. (Since all service workers *must* go through the\n                // waiting phase, the only way to detect `skipWaiting()` called in the\n                // install event is to observe that the time spent in the waiting phase\n                // is very short.)\n                // NOTE: we don't need separate timeouts for the own and external SWs\n                // since they can't go through these phases at the same time.\n                this._waitingTimeout = self.setTimeout(() => {\n                    // Ensure the SW is still waiting (it may now be redundant).\n                    if (state === 'installed' && registration.waiting === sw) {\n                        this.dispatchEvent(new WorkboxEvent('waiting', eventProps));\n                        if (process.env.NODE_ENV !== 'production') {\n                            if (isExternal) {\n                                logger.warn('An external service worker has installed but is ' +\n                                    'waiting for this client to close before activating...');\n                            }\n                            else {\n                                logger.warn('The service worker has installed but is waiting ' +\n                                    'for existing clients to close before activating...');\n                            }\n                        }\n                    }\n                }, WAITING_TIMEOUT_DURATION);\n            }\n            else if (state === 'activating') {\n                clearTimeout(this._waitingTimeout);\n                if (!isExternal) {\n                    this._activeDeferred.resolve(sw);\n                }\n            }\n            if (process.env.NODE_ENV !== 'production') {\n                switch (state) {\n                    case 'installed':\n                        if (isExternal) {\n                            logger.warn('An external service worker has installed. ' +\n                                'You may want to suggest users reload this page.');\n                        }\n                        else {\n                            logger.log('Registered service worker installed.');\n                        }\n                        break;\n                    case 'activated':\n                        if (isExternal) {\n                            logger.warn('An external service worker has activated.');\n                        }\n                        else {\n                            logger.log('Registered service worker activated.');\n                            if (sw !== navigator.serviceWorker.controller) {\n                                logger.warn('The registered service worker is active but ' +\n                                    'not yet controlling the page. Reload or run ' +\n                                    '`clients.claim()` in the service worker.');\n                            }\n                        }\n                        break;\n                    case 'redundant':\n                        if (sw === this._compatibleControllingSW) {\n                            logger.log('Previously controlling service worker now redundant!');\n                        }\n                        else if (!isExternal) {\n                            logger.log('Registered service worker now redundant!');\n                        }\n                        break;\n                }\n            }\n        };\n        /**\n         * @private\n         * @param {Event} originalEvent\n         */\n        this._onControllerChange = (originalEvent) => {\n            const sw = this._sw;\n            const isExternal = sw !== navigator.serviceWorker.controller;\n            // Unconditionally dispatch the controlling event, with isExternal set\n            // to distinguish between controller changes due to the initial registration\n            // vs. an update-check or other tab's registration.\n            // See https://github.com/GoogleChrome/workbox/issues/2786\n            this.dispatchEvent(new WorkboxEvent('controlling', {\n                isExternal,\n                originalEvent,\n                sw,\n                isUpdate: this._isUpdate,\n            }));\n            if (!isExternal) {\n                if (process.env.NODE_ENV !== 'production') {\n                    logger.log('Registered service worker now controlling this page.');\n                }\n                this._controllingDeferred.resolve(sw);\n            }\n        };\n        /**\n         * @private\n         * @param {Event} originalEvent\n         */\n        this._onMessage = async (originalEvent) => {\n            // Can't change type 'any' of data.\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            const { data, ports, source } = originalEvent;\n            // Wait until there's an \"own\" service worker. This is used to buffer\n            // `message` events that may be received prior to calling `register()`.\n            await this.getSW();\n            // If the service worker that sent the message is in the list of own\n            // service workers for this instance, dispatch a `message` event.\n            // NOTE: we check for all previously owned service workers rather than\n            // just the current one because some messages (e.g. cache updates) use\n            // a timeout when sent and may be delayed long enough for a service worker\n            // update to be found.\n            if (this._ownSWs.has(source)) {\n                this.dispatchEvent(new WorkboxEvent('message', {\n                    // Can't change type 'any' of data.\n                    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                    data,\n                    originalEvent,\n                    ports,\n                    sw: source,\n                }));\n            }\n        };\n        this._scriptURL = scriptURL;\n        this._registerOptions = registerOptions;\n        // Add a message listener immediately since messages received during\n        // page load are buffered only until the DOMContentLoaded event:\n        // https://github.com/GoogleChrome/workbox/issues/2202\n        navigator.serviceWorker.addEventListener('message', this._onMessage);\n    }\n    /**\n     * Registers a service worker for this instances script URL and service\n     * worker options. By default this method delays registration until after\n     * the window has loaded.\n     *\n     * @param {Object} [options]\n     * @param {Function} [options.immediate=false] Setting this to true will\n     *     register the service worker immediately, even if the window has\n     *     not loaded (not recommended).\n     */\n    async register({ immediate = false } = {}) {\n        if (process.env.NODE_ENV !== 'production') {\n            if (this._registrationTime) {\n                logger.error('Cannot re-register a Workbox instance after it has ' +\n                    'been registered. Create a new instance instead.');\n                return;\n            }\n        }\n        if (!immediate && document.readyState !== 'complete') {\n            await new Promise((res) => window.addEventListener('load', res));\n        }\n        // Set this flag to true if any service worker was controlling the page\n        // at registration time.\n        this._isUpdate = Boolean(navigator.serviceWorker.controller);\n        // Before registering, attempt to determine if a SW is already controlling\n        // the page, and if that SW script (and version, if specified) matches this\n        // instance's script.\n        this._compatibleControllingSW = this._getControllingSWIfCompatible();\n        this._registration = await this._registerScript();\n        // If we have a compatible controller, store the controller as the \"own\"\n        // SW, resolve active/controlling deferreds and add necessary listeners.\n        if (this._compatibleControllingSW) {\n            this._sw = this._compatibleControllingSW;\n            this._activeDeferred.resolve(this._compatibleControllingSW);\n            this._controllingDeferred.resolve(this._compatibleControllingSW);\n            this._compatibleControllingSW.addEventListener('statechange', this._onStateChange, { once: true });\n        }\n        // If there's a waiting service worker with a matching URL before the\n        // `updatefound` event fires, it likely means that this site is open\n        // in another tab, or the user refreshed the page (and thus the previous\n        // page wasn't fully unloaded before this page started loading).\n        // https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle#waiting\n        const waitingSW = this._registration.waiting;\n        if (waitingSW &&\n            urlsMatch(waitingSW.scriptURL, this._scriptURL.toString())) {\n            // Store the waiting SW as the \"own\" Sw, even if it means overwriting\n            // a compatible controller.\n            this._sw = waitingSW;\n            // Run this in the next microtask, so any code that adds an event\n            // listener after awaiting `register()` will get this event.\n            dontWaitFor(Promise.resolve().then(() => {\n                this.dispatchEvent(new WorkboxEvent('waiting', {\n                    sw: waitingSW,\n                    wasWaitingBeforeRegister: true,\n                }));\n                if (process.env.NODE_ENV !== 'production') {\n                    logger.warn('A service worker was already waiting to activate ' +\n                        'before this script was registered...');\n                }\n            }));\n        }\n        // If an \"own\" SW is already set, resolve the deferred.\n        if (this._sw) {\n            this._swDeferred.resolve(this._sw);\n            this._ownSWs.add(this._sw);\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            logger.log('Successfully registered service worker.', this._scriptURL.toString());\n            if (navigator.serviceWorker.controller) {\n                if (this._compatibleControllingSW) {\n                    logger.debug('A service worker with the same script URL ' +\n                        'is already controlling this page.');\n                }\n                else {\n                    logger.debug('A service worker with a different script URL is ' +\n                        'currently controlling the page. The browser is now fetching ' +\n                        'the new script now...');\n                }\n            }\n            const currentPageIsOutOfScope = () => {\n                const scopeURL = new URL(this._registerOptions.scope || this._scriptURL.toString(), document.baseURI);\n                const scopeURLBasePath = new URL('./', scopeURL.href).pathname;\n                return !location.pathname.startsWith(scopeURLBasePath);\n            };\n            if (currentPageIsOutOfScope()) {\n                logger.warn('The current page is not in scope for the registered ' +\n                    'service worker. Was this a mistake?');\n            }\n        }\n        this._registration.addEventListener('updatefound', this._onUpdateFound);\n        navigator.serviceWorker.addEventListener('controllerchange', this._onControllerChange);\n        return this._registration;\n    }\n    /**\n     * Checks for updates of the registered service worker.\n     */\n    async update() {\n        if (!this._registration) {\n            if (process.env.NODE_ENV !== 'production') {\n                logger.error('Cannot update a Workbox instance without ' +\n                    'being registered. Register the Workbox instance first.');\n            }\n            return;\n        }\n        // Try to update registration\n        await this._registration.update();\n    }\n    /**\n     * Resolves to the service worker registered by this instance as soon as it\n     * is active. If a service worker was already controlling at registration\n     * time then it will resolve to that if the script URLs (and optionally\n     * script versions) match, otherwise it will wait until an update is found\n     * and activates.\n     *\n     * @return {Promise<ServiceWorker>}\n     */\n    get active() {\n        return this._activeDeferred.promise;\n    }\n    /**\n     * Resolves to the service worker registered by this instance as soon as it\n     * is controlling the page. If a service worker was already controlling at\n     * registration time then it will resolve to that if the script URLs (and\n     * optionally script versions) match, otherwise it will wait until an update\n     * is found and starts controlling the page.\n     * Note: the first time a service worker is installed it will active but\n     * not start controlling the page unless `clients.claim()` is called in the\n     * service worker.\n     *\n     * @return {Promise<ServiceWorker>}\n     */\n    get controlling() {\n        return this._controllingDeferred.promise;\n    }\n    /**\n     * Resolves with a reference to a service worker that matches the script URL\n     * of this instance, as soon as it's available.\n     *\n     * If, at registration time, there's already an active or waiting service\n     * worker with a matching script URL, it will be used (with the waiting\n     * service worker taking precedence over the active service worker if both\n     * match, since the waiting service worker would have been registered more\n     * recently).\n     * If there's no matching active or waiting service worker at registration\n     * time then the promise will not resolve until an update is found and starts\n     * installing, at which point the installing service worker is used.\n     *\n     * @return {Promise<ServiceWorker>}\n     */\n    getSW() {\n        // If `this._sw` is set, resolve with that as we want `getSW()` to\n        // return the correct (new) service worker if an update is found.\n        return this._sw !== undefined\n            ? Promise.resolve(this._sw)\n            : this._swDeferred.promise;\n    }\n    /**\n     * Sends the passed data object to the service worker registered by this\n     * instance (via {@link workbox-window.Workbox#getSW}) and resolves\n     * with a response (if any).\n     *\n     * A response can be set in a message handler in the service worker by\n     * calling `event.ports[0].postMessage(...)`, which will resolve the promise\n     * returned by `messageSW()`. If no response is set, the promise will never\n     * resolve.\n     *\n     * @param {Object} data An object to send to the service worker\n     * @return {Promise<Object>}\n     */\n    // We might be able to change the 'data' type to Record<string, unknown> in the future.\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    async messageSW(data) {\n        const sw = await this.getSW();\n        return messageSW(sw, data);\n    }\n    /**\n     * Sends a `{type: 'SKIP_WAITING'}` message to the service worker that's\n     * currently in the `waiting` state associated with the current registration.\n     *\n     * If there is no current registration or no service worker is `waiting`,\n     * calling this will have no effect.\n     */\n    messageSkipWaiting() {\n        if (this._registration && this._registration.waiting) {\n            void messageSW(this._registration.waiting, SKIP_WAITING_MESSAGE);\n        }\n    }\n    /**\n     * Checks for a service worker already controlling the page and returns\n     * it if its script URL matches.\n     *\n     * @private\n     * @return {ServiceWorker|undefined}\n     */\n    _getControllingSWIfCompatible() {\n        const controller = navigator.serviceWorker.controller;\n        if (controller &&\n            urlsMatch(controller.scriptURL, this._scriptURL.toString())) {\n            return controller;\n        }\n        else {\n            return undefined;\n        }\n    }\n    /**\n     * Registers a service worker for this instances script URL and register\n     * options and tracks the time registration was complete.\n     *\n     * @private\n     */\n    async _registerScript() {\n        try {\n            // this._scriptURL may be a TrustedScriptURL, but there's no support for\n            // passing that to register() in lib.dom right now.\n            // https://github.com/GoogleChrome/workbox/issues/2855\n            const reg = await navigator.serviceWorker.register(this._scriptURL, this._registerOptions);\n            // Keep track of when registration happened, so it can be used in the\n            // `this._onUpdateFound` heuristic. Also use the presence of this\n            // property as a way to see if `.register()` has been called.\n            this._registrationTime = performance.now();\n            return reg;\n        }\n        catch (error) {\n            if (process.env.NODE_ENV !== 'production') {\n                logger.error(error);\n            }\n            // Re-throw the error.\n            throw error;\n        }\n    }\n}\nexport { Workbox };\n// The jsdoc comments below outline the events this instance may dispatch:\n// -----------------------------------------------------------------------\n/**\n * The `message` event is dispatched any time a `postMessage` is received.\n *\n * @event workbox-window.Workbox#message\n * @type {WorkboxEvent}\n * @property {*} data The `data` property from the original `message` event.\n * @property {Event} originalEvent The original [`message`]{@link https://developer.mozilla.org/en-US/docs/Web/API/MessageEvent}\n *     event.\n * @property {string} type `message`.\n * @property {MessagePort[]} ports The `ports` value from `originalEvent`.\n * @property {Workbox} target The `Workbox` instance.\n */\n/**\n * The `installed` event is dispatched if the state of a\n * {@link workbox-window.Workbox} instance's\n * {@link https://developers.google.com/web/tools/workbox/modules/workbox-precaching#def-registered-sw|registered service worker}\n * changes to `installed`.\n *\n * Then can happen either the very first time a service worker is installed,\n * or after an update to the current service worker is found. In the case\n * of an update being found, the event's `isUpdate` property will be `true`.\n *\n * @event workbox-window.Workbox#installed\n * @type {WorkboxEvent}\n * @property {ServiceWorker} sw The service worker instance.\n * @property {Event} originalEvent The original [`statechange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/onstatechange}\n *     event.\n * @property {boolean|undefined} isUpdate True if a service worker was already\n *     controlling when this `Workbox` instance called `register()`.\n * @property {boolean|undefined} isExternal True if this event is associated\n *     with an [external service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-window#when_an_unexpected_version_of_the_service_worker_is_found}.\n * @property {string} type `installed`.\n * @property {Workbox} target The `Workbox` instance.\n */\n/**\n * The `waiting` event is dispatched if the state of a\n * {@link workbox-window.Workbox} instance's\n * [registered service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-precaching#def-registered-sw}\n * changes to `installed` and then doesn't immediately change to `activating`.\n * It may also be dispatched if a service worker with the same\n * [`scriptURL`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/scriptURL}\n * was already waiting when the {@link workbox-window.Workbox#register}\n * method was called.\n *\n * @event workbox-window.Workbox#waiting\n * @type {WorkboxEvent}\n * @property {ServiceWorker} sw The service worker instance.\n * @property {Event|undefined} originalEvent The original\n *    [`statechange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/onstatechange}\n *     event, or `undefined` in the case where the service worker was waiting\n *     to before `.register()` was called.\n * @property {boolean|undefined} isUpdate True if a service worker was already\n *     controlling when this `Workbox` instance called `register()`.\n * @property {boolean|undefined} isExternal True if this event is associated\n *     with an [external service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-window#when_an_unexpected_version_of_the_service_worker_is_found}.\n * @property {boolean|undefined} wasWaitingBeforeRegister True if a service worker with\n *     a matching `scriptURL` was already waiting when this `Workbox`\n *     instance called `register()`.\n * @property {string} type `waiting`.\n * @property {Workbox} target The `Workbox` instance.\n */\n/**\n * The `controlling` event is dispatched if a\n * [`controllerchange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer/oncontrollerchange}\n * fires on the service worker [container]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer}\n * and the [`scriptURL`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/scriptURL}\n * of the new [controller]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer/controller}\n * matches the `scriptURL` of the `Workbox` instance's\n * [registered service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-precaching#def-registered-sw}.\n *\n * @event workbox-window.Workbox#controlling\n * @type {WorkboxEvent}\n * @property {ServiceWorker} sw The service worker instance.\n * @property {Event} originalEvent The original [`controllerchange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer/oncontrollerchange}\n *     event.\n * @property {boolean|undefined} isUpdate True if a service worker was already\n *     controlling when this service worker was registered.\n * @property {boolean|undefined} isExternal True if this event is associated\n *     with an [external service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-window#when_an_unexpected_version_of_the_service_worker_is_found}.\n * @property {string} type `controlling`.\n * @property {Workbox} target The `Workbox` instance.\n */\n/**\n * The `activated` event is dispatched if the state of a\n * {@link workbox-window.Workbox} instance's\n * {@link https://developers.google.com/web/tools/workbox/modules/workbox-precaching#def-registered-sw|registered service worker}\n * changes to `activated`.\n *\n * @event workbox-window.Workbox#activated\n * @type {WorkboxEvent}\n * @property {ServiceWorker} sw The service worker instance.\n * @property {Event} originalEvent The original [`statechange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/onstatechange}\n *     event.\n * @property {boolean|undefined} isUpdate True if a service worker was already\n *     controlling when this `Workbox` instance called `register()`.\n * @property {boolean|undefined} isExternal True if this event is associated\n *     with an [external service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-window#when_an_unexpected_version_of_the_service_worker_is_found}.\n * @property {string} type `activated`.\n * @property {Workbox} target The `Workbox` instance.\n */\n/**\n * The `redundant` event is dispatched if the state of a\n * {@link workbox-window.Workbox} instance's\n * [registered service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-precaching#def-registered-sw}\n * changes to `redundant`.\n *\n * @event workbox-window.Workbox#redundant\n * @type {WorkboxEvent}\n * @property {ServiceWorker} sw The service worker instance.\n * @property {Event} originalEvent The original [`statechange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/onstatechange}\n *     event.\n * @property {boolean|undefined} isUpdate True if a service worker was already\n *     controlling when this `Workbox` instance called `register()`.\n * @property {string} type `redundant`.\n * @property {Workbox} target The `Workbox` instance.\n */\n","/*\n  Copyright 2019 Google LLC\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport '../_version.js';\n/**\n * A helper function that prevents a promise from being flagged as unused.\n *\n * @private\n **/\nexport function dontWaitFor(promise) {\n    // Effective no-op.\n    void promise.then(() => { });\n}\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n/**\n * A minimal `EventTarget` shim.\n * This is necessary because not all browsers support constructable\n * `EventTarget`, so using a real `EventTarget` will error.\n * @private\n */\nexport class WorkboxEventTarget {\n    constructor() {\n        this._eventListenerRegistry = new Map();\n    }\n    /**\n     * @param {string} type\n     * @param {Function} listener\n     * @private\n     */\n    addEventListener(type, listener) {\n        const foo = this._getEventListenersByType(type);\n        foo.add(listener);\n    }\n    /**\n     * @param {string} type\n     * @param {Function} listener\n     * @private\n     */\n    removeEventListener(type, listener) {\n        this._getEventListenersByType(type).delete(listener);\n    }\n    /**\n     * @param {Object} event\n     * @private\n     */\n    dispatchEvent(event) {\n        event.target = this;\n        const listeners = this._getEventListenersByType(event.type);\n        for (const listener of listeners) {\n            listener(event);\n        }\n    }\n    /**\n     * Returns a Set of listeners associated with the passed event type.\n     * If no handlers have been registered, an empty Set is returned.\n     *\n     * @param {string} type The event type.\n     * @return {Set<ListenerCallback>} An array of handler functions.\n     * @private\n     */\n    _getEventListenersByType(type) {\n        if (!this._eventListenerRegistry.has(type)) {\n            this._eventListenerRegistry.set(type, new Set());\n        }\n        return this._eventListenerRegistry.get(type);\n    }\n}\n","function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nexport default function _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}","export default function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}","import _typeof from \"./typeof.js\";\nexport default function _regeneratorRuntime() {\n  \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */\n  _regeneratorRuntime = function _regeneratorRuntime() {\n    return exports;\n  };\n  var exports = {},\n    Op = Object.prototype,\n    hasOwn = Op.hasOwnProperty,\n    $Symbol = \"function\" == typeof Symbol ? Symbol : {},\n    iteratorSymbol = $Symbol.iterator || \"@@iterator\",\n    asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\",\n    toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n  function define(obj, key, value) {\n    return Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: !0,\n      configurable: !0,\n      writable: !0\n    }), obj[key];\n  }\n  try {\n    define({}, \"\");\n  } catch (err) {\n    define = function define(obj, key, value) {\n      return obj[key] = value;\n    };\n  }\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator,\n      generator = Object.create(protoGenerator.prototype),\n      context = new Context(tryLocsList || []);\n    return generator._invoke = function (innerFn, self, context) {\n      var state = \"suspendedStart\";\n      return function (method, arg) {\n        if (\"executing\" === state) throw new Error(\"Generator is already running\");\n        if (\"completed\" === state) {\n          if (\"throw\" === method) throw arg;\n          return doneResult();\n        }\n        for (context.method = method, context.arg = arg;;) {\n          var delegate = context.delegate;\n          if (delegate) {\n            var delegateResult = maybeInvokeDelegate(delegate, context);\n            if (delegateResult) {\n              if (delegateResult === ContinueSentinel) continue;\n              return delegateResult;\n            }\n          }\n          if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) {\n            if (\"suspendedStart\" === state) throw state = \"completed\", context.arg;\n            context.dispatchException(context.arg);\n          } else \"return\" === context.method && context.abrupt(\"return\", context.arg);\n          state = \"executing\";\n          var record = tryCatch(innerFn, self, context);\n          if (\"normal\" === record.type) {\n            if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue;\n            return {\n              value: record.arg,\n              done: context.done\n            };\n          }\n          \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg);\n        }\n      };\n    }(innerFn, self, context), generator;\n  }\n  function tryCatch(fn, obj, arg) {\n    try {\n      return {\n        type: \"normal\",\n        arg: fn.call(obj, arg)\n      };\n    } catch (err) {\n      return {\n        type: \"throw\",\n        arg: err\n      };\n    }\n  }\n  exports.wrap = wrap;\n  var ContinueSentinel = {};\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n  var IteratorPrototype = {};\n  define(IteratorPrototype, iteratorSymbol, function () {\n    return this;\n  });\n  var getProto = Object.getPrototypeOf,\n    NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);\n  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function (method) {\n      define(prototype, method, function (arg) {\n        return this._invoke(method, arg);\n      });\n    });\n  }\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (\"throw\" !== record.type) {\n        var result = record.arg,\n          value = result.value;\n        return value && \"object\" == _typeof(value) && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) {\n          invoke(\"next\", value, resolve, reject);\n        }, function (err) {\n          invoke(\"throw\", err, resolve, reject);\n        }) : PromiseImpl.resolve(value).then(function (unwrapped) {\n          result.value = unwrapped, resolve(result);\n        }, function (error) {\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n      reject(record.arg);\n    }\n    var previousPromise;\n    this._invoke = function (method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new PromiseImpl(function (resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n      return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();\n    };\n  }\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (undefined === method) {\n      if (context.delegate = null, \"throw\" === context.method) {\n        if (delegate.iterator[\"return\"] && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method)) return ContinueSentinel;\n        context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a 'throw' method\");\n      }\n      return ContinueSentinel;\n    }\n    var record = tryCatch(method, delegate.iterator, context.arg);\n    if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel;\n    var info = record.arg;\n    return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel);\n  }\n  function pushTryEntry(locs) {\n    var entry = {\n      tryLoc: locs[0]\n    };\n    1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);\n  }\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\", delete record.arg, entry.completion = record;\n  }\n  function Context(tryLocsList) {\n    this.tryEntries = [{\n      tryLoc: \"root\"\n    }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0);\n  }\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) return iteratorMethod.call(iterable);\n      if (\"function\" == typeof iterable.next) return iterable;\n      if (!isNaN(iterable.length)) {\n        var i = -1,\n          next = function next() {\n            for (; ++i < iterable.length;) {\n              if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next;\n            }\n            return next.value = undefined, next.done = !0, next;\n          };\n        return next.next = next;\n      }\n    }\n    return {\n      next: doneResult\n    };\n  }\n  function doneResult() {\n    return {\n      value: undefined,\n      done: !0\n    };\n  }\n  return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, \"constructor\", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) {\n    var ctor = \"function\" == typeof genFun && genFun.constructor;\n    return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name));\n  }, exports.mark = function (genFun) {\n    return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun;\n  }, exports.awrap = function (arg) {\n    return {\n      __await: arg\n    };\n  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () {\n    return this;\n  }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    void 0 === PromiseImpl && (PromiseImpl = Promise);\n    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);\n    return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) {\n      return result.done ? result.value : iter.next();\n    });\n  }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () {\n    return this;\n  }), define(Gp, \"toString\", function () {\n    return \"[object Generator]\";\n  }), exports.keys = function (object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    return keys.reverse(), function next() {\n      for (; keys.length;) {\n        var key = keys.pop();\n        if (key in object) return next.value = key, next.done = !1, next;\n      }\n      return next.done = !0, next;\n    };\n  }, exports.values = values, Context.prototype = {\n    constructor: Context,\n    reset: function reset(skipTempReset) {\n      if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) {\n        \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined);\n      }\n    },\n    stop: function stop() {\n      this.done = !0;\n      var rootRecord = this.tryEntries[0].completion;\n      if (\"throw\" === rootRecord.type) throw rootRecord.arg;\n      return this.rval;\n    },\n    dispatchException: function dispatchException(exception) {\n      if (this.done) throw exception;\n      var context = this;\n      function handle(loc, caught) {\n        return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught;\n      }\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i],\n          record = entry.completion;\n        if (\"root\" === entry.tryLoc) return handle(\"end\");\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\"),\n            hasFinally = hasOwn.call(entry, \"finallyLoc\");\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);\n            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);\n          } else {\n            if (!hasFinally) throw new Error(\"try statement without catch or finally\");\n            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);\n          }\n        }\n      }\n    },\n    abrupt: function abrupt(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n      finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);\n      var record = finallyEntry ? finallyEntry.completion : {};\n      return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);\n    },\n    complete: function complete(record, afterLoc) {\n      if (\"throw\" === record.type) throw record.arg;\n      return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;\n    },\n    finish: function finish(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;\n      }\n    },\n    \"catch\": function _catch(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (\"throw\" === record.type) {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n      throw new Error(\"illegal catch attempt\");\n    },\n    delegateYield: function delegateYield(iterable, resultName, nextLoc) {\n      return this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel;\n    }\n  }, exports;\n}","function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\nexport default function _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n      args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n      _next(undefined);\n    });\n  };\n}","export default function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}","import defineProperty from \"./defineProperty.js\";\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nexport default function _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}","const instanceOfAny = (object, constructors) => constructors.some((c) => object instanceof c);\n\nlet idbProxyableTypes;\nlet cursorAdvanceMethods;\n// This is a function to prevent it throwing up in node environments.\nfunction getIdbProxyableTypes() {\n    return (idbProxyableTypes ||\n        (idbProxyableTypes = [\n            IDBDatabase,\n            IDBObjectStore,\n            IDBIndex,\n            IDBCursor,\n            IDBTransaction,\n        ]));\n}\n// This is a function to prevent it throwing up in node environments.\nfunction getCursorAdvanceMethods() {\n    return (cursorAdvanceMethods ||\n        (cursorAdvanceMethods = [\n            IDBCursor.prototype.advance,\n            IDBCursor.prototype.continue,\n            IDBCursor.prototype.continuePrimaryKey,\n        ]));\n}\nconst cursorRequestMap = new WeakMap();\nconst transactionDoneMap = new WeakMap();\nconst transactionStoreNamesMap = new WeakMap();\nconst transformCache = new WeakMap();\nconst reverseTransformCache = new WeakMap();\nfunction promisifyRequest(request) {\n    const promise = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            request.removeEventListener('success', success);\n            request.removeEventListener('error', error);\n        };\n        const success = () => {\n            resolve(wrap(request.result));\n            unlisten();\n        };\n        const error = () => {\n            reject(request.error);\n            unlisten();\n        };\n        request.addEventListener('success', success);\n        request.addEventListener('error', error);\n    });\n    promise\n        .then((value) => {\n        // Since cursoring reuses the IDBRequest (*sigh*), we cache it for later retrieval\n        // (see wrapFunction).\n        if (value instanceof IDBCursor) {\n            cursorRequestMap.set(value, request);\n        }\n        // Catching to avoid \"Uncaught Promise exceptions\"\n    })\n        .catch(() => { });\n    // This mapping exists in reverseTransformCache but doesn't doesn't exist in transformCache. This\n    // is because we create many promises from a single IDBRequest.\n    reverseTransformCache.set(promise, request);\n    return promise;\n}\nfunction cacheDonePromiseForTransaction(tx) {\n    // Early bail if we've already created a done promise for this transaction.\n    if (transactionDoneMap.has(tx))\n        return;\n    const done = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            tx.removeEventListener('complete', complete);\n            tx.removeEventListener('error', error);\n            tx.removeEventListener('abort', error);\n        };\n        const complete = () => {\n            resolve();\n            unlisten();\n        };\n        const error = () => {\n            reject(tx.error || new DOMException('AbortError', 'AbortError'));\n            unlisten();\n        };\n        tx.addEventListener('complete', complete);\n        tx.addEventListener('error', error);\n        tx.addEventListener('abort', error);\n    });\n    // Cache it for later retrieval.\n    transactionDoneMap.set(tx, done);\n}\nlet idbProxyTraps = {\n    get(target, prop, receiver) {\n        if (target instanceof IDBTransaction) {\n            // Special handling for transaction.done.\n            if (prop === 'done')\n                return transactionDoneMap.get(target);\n            // Polyfill for objectStoreNames because of Edge.\n            if (prop === 'objectStoreNames') {\n                return target.objectStoreNames || transactionStoreNamesMap.get(target);\n            }\n            // Make tx.store return the only store in the transaction, or undefined if there are many.\n            if (prop === 'store') {\n                return receiver.objectStoreNames[1]\n                    ? undefined\n                    : receiver.objectStore(receiver.objectStoreNames[0]);\n            }\n        }\n        // Else transform whatever we get back.\n        return wrap(target[prop]);\n    },\n    set(target, prop, value) {\n        target[prop] = value;\n        return true;\n    },\n    has(target, prop) {\n        if (target instanceof IDBTransaction &&\n            (prop === 'done' || prop === 'store')) {\n            return true;\n        }\n        return prop in target;\n    },\n};\nfunction replaceTraps(callback) {\n    idbProxyTraps = callback(idbProxyTraps);\n}\nfunction wrapFunction(func) {\n    // Due to expected object equality (which is enforced by the caching in `wrap`), we\n    // only create one new func per func.\n    // Edge doesn't support objectStoreNames (booo), so we polyfill it here.\n    if (func === IDBDatabase.prototype.transaction &&\n        !('objectStoreNames' in IDBTransaction.prototype)) {\n        return function (storeNames, ...args) {\n            const tx = func.call(unwrap(this), storeNames, ...args);\n            transactionStoreNamesMap.set(tx, storeNames.sort ? storeNames.sort() : [storeNames]);\n            return wrap(tx);\n        };\n    }\n    // Cursor methods are special, as the behaviour is a little more different to standard IDB. In\n    // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the\n    // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense\n    // with real promises, so each advance methods returns a new promise for the cursor object, or\n    // undefined if the end of the cursor has been reached.\n    if (getCursorAdvanceMethods().includes(func)) {\n        return function (...args) {\n            // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n            // the original object.\n            func.apply(unwrap(this), args);\n            return wrap(cursorRequestMap.get(this));\n        };\n    }\n    return function (...args) {\n        // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n        // the original object.\n        return wrap(func.apply(unwrap(this), args));\n    };\n}\nfunction transformCachableValue(value) {\n    if (typeof value === 'function')\n        return wrapFunction(value);\n    // This doesn't return, it just creates a 'done' promise for the transaction,\n    // which is later returned for transaction.done (see idbObjectHandler).\n    if (value instanceof IDBTransaction)\n        cacheDonePromiseForTransaction(value);\n    if (instanceOfAny(value, getIdbProxyableTypes()))\n        return new Proxy(value, idbProxyTraps);\n    // Return the same value back if we're not going to transform it.\n    return value;\n}\nfunction wrap(value) {\n    // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because\n    // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.\n    if (value instanceof IDBRequest)\n        return promisifyRequest(value);\n    // If we've already transformed this value before, reuse the transformed value.\n    // This is faster, but it also provides object equality.\n    if (transformCache.has(value))\n        return transformCache.get(value);\n    const newValue = transformCachableValue(value);\n    // Not all types are transformed.\n    // These may be primitive types, so they can't be WeakMap keys.\n    if (newValue !== value) {\n        transformCache.set(value, newValue);\n        reverseTransformCache.set(newValue, value);\n    }\n    return newValue;\n}\nconst unwrap = (value) => reverseTransformCache.get(value);\n\nexport { reverseTransformCache as a, instanceOfAny as i, replaceTraps as r, unwrap as u, wrap as w };\n","import { w as wrap, r as replaceTraps } from './wrap-idb-value.js';\nexport { u as unwrap, w as wrap } from './wrap-idb-value.js';\n\n/**\n * Open a database.\n *\n * @param name Name of the database.\n * @param version Schema version.\n * @param callbacks Additional callbacks.\n */\nfunction openDB(name, version, { blocked, upgrade, blocking, terminated } = {}) {\n    const request = indexedDB.open(name, version);\n    const openPromise = wrap(request);\n    if (upgrade) {\n        request.addEventListener('upgradeneeded', (event) => {\n            upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction), event);\n        });\n    }\n    if (blocked) {\n        request.addEventListener('blocked', (event) => blocked(\n        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n        event.oldVersion, event.newVersion, event));\n    }\n    openPromise\n        .then((db) => {\n        if (terminated)\n            db.addEventListener('close', () => terminated());\n        if (blocking) {\n            db.addEventListener('versionchange', (event) => blocking(event.oldVersion, event.newVersion, event));\n        }\n    })\n        .catch(() => { });\n    return openPromise;\n}\n/**\n * Delete a database.\n *\n * @param name Name of the database.\n */\nfunction deleteDB(name, { blocked } = {}) {\n    const request = indexedDB.deleteDatabase(name);\n    if (blocked) {\n        request.addEventListener('blocked', (event) => blocked(\n        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n        event.oldVersion, event));\n    }\n    return wrap(request).then(() => undefined);\n}\n\nconst readMethods = ['get', 'getKey', 'getAll', 'getAllKeys', 'count'];\nconst writeMethods = ['put', 'add', 'delete', 'clear'];\nconst cachedMethods = new Map();\nfunction getMethod(target, prop) {\n    if (!(target instanceof IDBDatabase &&\n        !(prop in target) &&\n        typeof prop === 'string')) {\n        return;\n    }\n    if (cachedMethods.get(prop))\n        return cachedMethods.get(prop);\n    const targetFuncName = prop.replace(/FromIndex$/, '');\n    const useIndex = prop !== targetFuncName;\n    const isWrite = writeMethods.includes(targetFuncName);\n    if (\n    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.\n    !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) ||\n        !(isWrite || readMethods.includes(targetFuncName))) {\n        return;\n    }\n    const method = async function (storeName, ...args) {\n        // isWrite ? 'readwrite' : undefined gzipps better, but fails in Edge :(\n        const tx = this.transaction(storeName, isWrite ? 'readwrite' : 'readonly');\n        let target = tx.store;\n        if (useIndex)\n            target = target.index(args.shift());\n        // Must reject if op rejects.\n        // If it's a write operation, must reject if tx.done rejects.\n        // Must reject with op rejection first.\n        // Must resolve with op value.\n        // Must handle both promises (no unhandled rejections)\n        return (await Promise.all([\n            target[targetFuncName](...args),\n            isWrite && tx.done,\n        ]))[0];\n    };\n    cachedMethods.set(prop, method);\n    return method;\n}\nreplaceTraps((oldTraps) => ({\n    ...oldTraps,\n    get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),\n    has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop),\n}));\n\nexport { deleteDB, openDB };\n","import { openDB } from 'idb';\n\nconst initdb = async () =>\n  openDB('jate', 1, {\n    upgrade(db) {\n      if (db.objectStoreNames.contains('jate')) {\n        console.log('jate database already exists');\n        return;\n      }\n      db.createObjectStore('jate', { keyPath: 'id', autoIncrement: true });\n      console.log('jate database created');\n    },\n  });\n\n// GET function\nexport const getDb = async (value) => {\n  console.log('Getting data from the jateDB');\n  // connect to DB and version we want to use\n  const jateDb = await openDB('jate', 1);\n  // transactionto specify the DB we are posting to and the data privileges. \n  const tx = jateDb.transaction('jate', 'readwrite');\n  // open the object store\n  const objStore = tx.objectStore('jate');\n  // use the .getAll() method to grab all the content in the DB\n  const req = objStore.getAll()\n  // confirm the data was fetched\n  const res = await req;\n  console.log('data saved to the jateDB', res);\n};\n\n// PUT function\nexport const putDb = async (id, value) => {\n  console.log('PUT request to update the jateDB');\n  // connect to DB and version we want to use\n  const jateDb = await openDB('jate', 1);\n  // mnew trans to specify the DB we are posting to and the data privileges. \n  const tx = jateDb.transaction('jate', 'readwrite');\n  // open the object store\n  const objStore = tx.objectStore('jate');\n  // use the .add() method to pass in content\n  const req = objStore.put({ id: id, value: value })\n  // confirm the data was added\n  const res = await req;\n  console.log('data saved to the jateDB', res);\n};\n\ninitdb();\n","const header = `\n/*\n       _____  ____________\n      / /   |/_  __/ ____/\n __  / / /| | / / / __/   \n/ /_/ / ___ |/ / / /___   \n ____/_/  |_/_/ /_____/   \njust another text editor\n*/                          \n`;\n\nexport { header };\n","// Import methods to save and get data from the indexedDB database in './database.js'\nimport { getDb, putDb } from './database';\nimport { header } from './header';\n\nexport default class {\n  constructor() {\n    const localData = localStorage.getItem('content');\n\n    // check if CodeMirror is loaded\n    if (typeof CodeMirror === 'undefined') {\n      throw new Error('CodeMirror is not loaded');\n    }\n\n    this.editor = CodeMirror(document.querySelector('#main'), {\n      value: '',\n      mode: 'javascript',\n      theme: 'monokai',\n      lineNumbers: true,\n      lineWrapping: true,\n      autofocus: true,\n      indentUnit: 2,\n      tabSize: 2,\n    });\n\n    // When the editor is ready, set the value to whatever is stored in indexeddb.\n    // Fall back to localStorage if nothing is stored in indexeddb, and if neither is available, set the value to header.\n    getDb().then((data) => {\n      console.info('Loaded data from IndexedDB, injecting into editor');\n      this.editor.setValue(data || localData || header);\n    });\n\n    this.editor.on('change', () => {\n      localStorage.setItem('content', this.editor.getValue());\n    });\n\n    // Save the content of the editor when the editor itself is loses focus\n    this.editor.on('blur', () => {\n      console.log('The editor has lost focus');\n      putDb(localStorage.getItem('content'));\n    });\n  }\n}\n","export default function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}","import { Workbox } from 'workbox-window';\nimport Editor from './js/editor';\nimport './js/database';\nimport './css/style.css';\n\nconst main = document.querySelector('#main');\nmain.innerHTML = '';\n\nconst loadSpinner = () => {\n  const spinner = document.createElement('div');\n  spinner.classList.add('spinner');\n  spinner.innerHTML = `\n  <div class=\"loading-container\">\n  <div class=\"loading-spinner\" />\n  </div>\n  `;\n  main.appendChild(spinner);\n};\n\nconst editor = new Editor();\n\nif (typeof editor === 'undefined') {\n  loadSpinner();\n}\n\n// Check if service workers are supported\nif ('serviceWorker' in navigator) {\n  // register workbox service worker\n  const workboxSW = new Workbox('/src-sw.js');\n  workboxSW.register();\n} else {\n  console.error('Service workers are not supported in this browser.');\n}\n"],"names":["self","_","e","messageSW","sw","data","Promise","resolve","messageChannel","MessageChannel","port1","onmessage","event","postMessage","port2","Deferred","promise","reject","_this","urlsMatch","url1","url2","href","location","URL","WorkboxEvent","type","props","Object","assign","this","_await","value","then","direct","_empty","SKIP_WAITING_MESSAGE","_awaitIgnored","Workbox","scriptURL","registerOptions","f","_registerOptions","_updateFoundCount","_swDeferred","_activeDeferred","_controllingDeferred","_registrationTime","_ownSWs","Set","_onUpdateFound","registration","_registration","installingSW","installing","_scriptURL","toString","performance","now","_externalSW","removeEventListener","_sw","add","addEventListener","_onStateChange","originalEvent","target","state","isExternal","eventProps","_isUpdate","isUpdate","dispatchEvent","_waitingTimeout","setTimeout","waiting","clearTimeout","_onControllerChange","navigator","serviceWorker","controller","_onMessage","ports","source","getSW","has","args","i","arguments","length","apply","register","immediate","body","result","document","readyState","res","window","Boolean","_compatibleControllingSW","_this3","_getControllingSWIfCompatible","_registerScript","once","waitingSW","wasWaitingBeforeRegister","update","messageSkipWaiting","recover","_this9","reg","error","_eventListenerRegistry","Map","listener","_getEventListenersByType","delete","set","get","_defineProperties","descriptor","enumerable","configurable","writable","defineProperty","key","_createClass","Constructor","protoProps","staticProps","prototype","_typeof","obj","Symbol","iterator","constructor","_regeneratorRuntime","exports","Op","hasOwn","hasOwnProperty","$Symbol","iteratorSymbol","asyncIteratorSymbol","asyncIterator","toStringTagSymbol","toStringTag","define","err","wrap","innerFn","outerFn","tryLocsList","protoGenerator","Generator","generator","create","context","Context","_invoke","method","arg","Error","doneResult","delegate","delegateResult","maybeInvokeDelegate","ContinueSentinel","sent","_sent","dispatchException","abrupt","record","tryCatch","done","fn","call","GeneratorFunction","GeneratorFunctionPrototype","IteratorPrototype","getProto","getPrototypeOf","NativeIteratorPrototype","values","Gp","defineIteratorMethods","forEach","AsyncIterator","PromiseImpl","invoke","__await","unwrapped","previousPromise","callInvokeWithMethodAndArg","undefined","TypeError","info","resultName","next","nextLoc","pushTryEntry","locs","entry","tryLoc","catchLoc","finallyLoc","afterLoc","tryEntries","push","resetTryEntry","completion","reset","iterable","iteratorMethod","isNaN","displayName","isGeneratorFunction","genFun","ctor","name","mark","setPrototypeOf","__proto__","awrap","async","iter","keys","object","reverse","pop","skipTempReset","prev","charAt","slice","stop","rootRecord","rval","exception","handle","loc","caught","hasCatch","hasFinally","finallyEntry","complete","finish","thrown","delegateYield","asyncGeneratorStep","gen","_next","_throw","_asyncToGenerator","_defineProperty","ownKeys","enumerableOnly","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","_objectSpread2","getOwnPropertyDescriptors","defineProperties","idbProxyableTypes","cursorAdvanceMethods","cursorRequestMap","WeakMap","transactionDoneMap","transactionStoreNamesMap","transformCache","reverseTransformCache","idbProxyTraps","prop","receiver","IDBTransaction","objectStoreNames","objectStore","wrapFunction","func","IDBDatabase","transaction","IDBCursor","advance","continue","continuePrimaryKey","includes","unwrap","storeNames","tx","sort","transformCachableValue","unlisten","DOMException","cacheDonePromiseForTransaction","IDBObjectStore","IDBIndex","some","c","Proxy","IDBRequest","request","success","catch","promisifyRequest","newValue","openDB","version","blocked","upgrade","blocking","terminated","indexedDB","open","openPromise","oldVersion","newVersion","db","readMethods","writeMethods","cachedMethods","getMethod","targetFuncName","replace","useIndex","isWrite","storeName","store","index","shift","all","oldTraps","callback","initdb","contains","console","log","createObjectStore","keyPath","autoIncrement","getDb","jateDb","objStore","req","getAll","putDb","id","put","instance","localData","localStorage","getItem","CodeMirror","editor","querySelector","mode","theme","lineNumbers","lineWrapping","autofocus","indentUnit","tabSize","setValue","on","setItem","getValue","main","innerHTML","Editor","spinner","createElement","classList","appendChild","loadSpinner"],"sourceRoot":""}